# <深入理解计算机系统> - B站课程 by 九曲阑干

## 3-1 程序的机器级表示
====

![](images/2022-02-02-06-48-43.png)

参数入栈从右到左一次保存在寄存器: %rdx, %rsi, %rdi
* 第1个参数: %rdi
* 第2个参数: %rsi
* 第3个参数: %rdx
* 第4个参数: %rcx
* 第5个参数: %r8
* 第6个参数: %r9
![](images/2022-02-02-06-49-24.png)

不同的寄存器有不同的保存策略：
* Calleed saved： %rbx, %rbp, %12, %13, %14, %15
* Caller saved:
  * %10, %11
  * %rax
  * %rdi, %rsi, %rdx, %rcx, %r8, %r9
![](images/2022-02-02-06-50-44.png)

## 3-2 寄存器与数据传送指令
![](images/2022-02-02-06-58-15.png)
![](images/2022-02-02-06-58-50.png)
![](images/2022-02-02-06-59-15.png)
![](images/2022-02-02-06-59-41.png)
![](images/2022-02-02-07-02-29.png)

![](images/2022-02-02-07-05-12.png)
![](images/2022-02-02-07-07-03.png)
![](images/2022-02-02-07-10-08.png)
![](images/2022-02-02-07-11-38.png)
![](images/2022-02-02-07-12-43.png)
![](images/2022-02-02-07-13-29.png)

![](images/2022-02-02-07-19-35.png)
![](images/2022-02-02-07-23-07.png)
上图最后一条指令：64位寄存器的规定，即任何位寄存器生成32位值的指令都会把该寄存器的高位部分置为0
![](images/2022-02-02-07-26-06.png)
没有movzlq，是因为movl就是默认将高32位置零。
![](images/2022-02-02-07-28-09.png)
cltq指令与movslq相同，操作数总是%eax,%rax寄存器，进行符号位扩展

![](images/2022-02-02-07-30-39.png)

## 3-3 栈与数据传送指令
![](images/2022-02-02-07-32-05.png)
![](images/2022-02-02-07-42-43.png)
![](images/2022-02-02-07-44-31.png)
![](images/2022-02-02-07-47-11.png)

## 3-4 算术逻辑指令
![](images/2022-02-02-07-49-24.png)
![](images/2022-02-02-07-51-28.png)
![](images/2022-02-02-07-52-00.png)
> 注意算术运算的第一个操作数是`D`，目的操作数
![](images/2022-02-02-07-52-56.png)

![](images/2022-02-02-07-56-42.png)
![](images/2022-02-02-07-58-23.png)
![](images/2022-02-02-07-59-14.png)
![](images/2022-02-02-08-00-16.png)

## 3-5 指令与条件码
![](images/2022-02-02-09-59-14.png)
> CF: 无符号数相加，产生进位
> OF: 有符号数相加，产生正溢出或负溢出
![](images/2022-02-02-10-02-24.png)
![](images/2022-02-02-10-06-05.png)
![](images/2022-02-02-10-08-16.png)
![](images/2022-02-02-10-11-46.png)
![](images/2022-02-02-10-14-21.png)
![](images/2022-02-02-10-15-03.png)

## 3-6 跳转指令与循环
![](images/2022-02-02-10-17-33.png)
![](images/2022-02-02-10-18-48.png)
> 这段代码的实现运行效率会比上面的高，关键在于`cmovge`指令
> cmovge %rdx, %rax =>>> ~(SF ^ OF)
> 基于条件码的组合来进行有条件的数据传送
![](images/2022-02-02-10-21-14.png)
![](images/2022-02-02-10-23-26.png)

![](images/2022-02-02-10-26-55.png)

![](images/2022-02-02-10-30-12.png)
![](images/2022-02-02-10-29-54.png)
![](images/2022-02-02-10-31-21.png)

## 3-7 过程(函数调用)
![](images/2022-02-02-10-39-17.png)
![](images/2022-02-02-10-41-27.png)
> first 6 arguments are passed in through registers
> %r8w => word long for %r8
> the last 2 arguments are passed through stack
> the arguments through stack are aligned to 8 bytes (64bits)
![](images/2022-02-02-10-42-57.png)

![](images/2022-02-02-10-45-24.png)
![](images/2022-02-02-10-46-11.png)

> leaq 8(%rsp), %rsi => 将arg2的地址作为第二个参数放到%rsi
> movq %rsp, %rdi => 将arg1的地址作为第一个参数放到%rdi
![](images/2022-02-02-10-49-47.png)

> 函数调用传参时需要对齐到8个字节，但是局部变量不需要
![](images/2022-02-02-10-55-18.png)

![](images/2022-02-02-11-04-00.png)
![](images/2022-02-02-11-05-15.png)

## 3-9 结构与联合体
![](images/2022-02-02-11-15-21.png)
![](images/2022-02-02-11-16-24.png)
![](images/2022-02-02-11-18-37.png)
![](images/2022-02-02-11-20-03.png)
![](images/2022-02-02-11-20-39.png)
![](images/2022-02-02-11-21-38.png)

![](images/2022-02-02-11-27-22.png)
