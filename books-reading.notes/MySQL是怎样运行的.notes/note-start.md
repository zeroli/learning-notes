# 书<MySQL是怎样运行的 - 从根儿上理解MySQL>阅读笔记

![](images/2022-01-18-07-13-04.png)

这本书豆瓣评分很高：9.2
https://book.douban.com/subject/35231266/

https://juejin.cn/book/6844733769996304392

总共分为4给部分:
|部分	|简介	|描述  |
|  --- |  --- | --- |
|第一部分	|入门	|以只会写增删改查语句的小白身份重新审视一下MySQL到底是个什么东东，会介绍MySQL的服务器程序和客户端程序有哪些，包括启动选项和系统变量以及字符集的一些事情。|
|第二部分	|基础结构相关	|唠叨记录、页面、索引、表空间的结构和用法，是全篇的基础，后边的章节都依赖于这些结构。|
|第三部分	|查询优化相关	|介绍同学们工作中经常遇到的查询优化问题，介绍单表查询是如何执行的，连接查询是怎么执行的，MySQL基于成本和规则的优化是个什么东西，以及会十分详细地介绍查看Explain语句执行结果的办法。|
|第四部分	|事务和锁相关	|介绍为什么会有事务的概念，以及MySQL是如何实现事务的，包括redo日志、undo日志、MVCC、各种锁的细节等～|

如下是它的目录：
```
第0章　楔子——阅读前必看 1
第1章　装作自己是个小白——初识MySQL 3
1.1　MySQL的客户端/服务器架构 3
1.2　MySQL的安装 3
1.3　启动MySQL服务器程序 5
1.3.1　在类UNIX系统中启动服务器程序 5
1.3.2　在Windows系统中启动服务器程序 6
1.4　启动MySQL客户端程序 7
1.5　客户端与服务器连接的过程 10
1.5.1　TCP/IP 10
1.5.2　命名管道和共享内存 10
1.5.3　UNIX域套接字 11
1.6　服务器处理客户端请求 11
1.6.1　连接管理 12
1.6.2　解析与优化 12
1.6.3　存储引擎 14
1.7　常用存储引擎 14
1.8　关于存储引擎的一些操作 16
1.8.1　查看当前服务器程序支持的存储引擎 16
1.8.2　设置表的存储引擎 16
1.9　总结 17
第2章　MySQL的调控按钮——启动选项和系统变量 19
2.1　启动选项和配置文件 19
2.1.1　在命令行上使用选项 19
2.1.2　配置文件中使用选项 21
2.1.3　在命令行和配置文件中启动选项的区别 26
2.2　系统变量 27
2.2.1　系统变量简介 27
2.2.2　查看系统变量 27
2.2.3　设置系统变量 28
2.3　状态变量 32
2.4　总结 32
第3章　字符集和比较规则 34
3.1　字符集和比较规则简介 34
3.1.1　字符集简介 34
3.1.2　比较规则简介 34
3.1.3　一些重要的字符集 35
3.2　MySQL中支持的字符集和比较规则 36
3.2.1　MySQL中的utf8和utf8mb4 36
3.2.2　字符集的查看 36
3.2.3　比较规则的查看 38
3.3　字符集和比较规则的应用 39
3.3.1　各级别的字符集和比较规则 39
3.3.2　客户端和服务器通信过程中使用的字符集 44
3.3.3　比较规则的应用 52
3.4　总结 53
第4章　从一条记录说起——InnoDB记录存储结构 55
4.1　准备工作 55
4.2　InnoDB页简介 55
4.3　InnoDB行格式 56
4.3.1　指定行格式的语法 56
4.3.2　COMPACT行格式 56
4.3.3　REDUNDANT行格式 64
4.3.4　溢出列 68
4.3.5　DYNAMIC行格式和COMPRESSED行格式 70
4.4　总结 71
第5章　盛放记录的大盒子——InnoDB数据页结构 72
5.1　不同类型的页简介 72
5.2　数据页结构快览 72
5.3　记录在页中的存储 73
5.4　Page Directory（页目录） 80
5.5　Page Header（页面头部） 85
5.6　File Header（文件头部） 86
5.7　File Trailer（文件尾部） 88
5.8　总结 88
第6章　快速查询的秘籍——B+树索引 90
6.1　没有索引时进行查找 90
6.1.1　在一个页中查找 90
6.1.2　在很多页中查找 91
6.2　索引 91
6.2.1　一个简单的索引方案 92
6.2.2　InnoDB中的索引方案 94
6.2.3　InnoDB中B+树索引的注意事项 102
6.2.4　MyISAM中的索引方案简介 104
6.2.5　MySQL中创建和删除索引的语句 105
6.3　总结 106
第7章 B+树索引的使用 107
7.1　B+树索引示意图的简化 107
7.2　索引的代价 109
7.3　应用B+树索引 110
7.3.1　扫描区间和边界条件 110
7.3.2　索引用于排序 122
7.3.3　索引用于分组 125
7.4　回表的代价 126
7.5　更好地创建和使用索引 127
7.5.1　只为用于搜索、排序或分组的列创建索引 127
7.5.2　考虑索引列中不重复值的个数 127
7.5.3　索引列的类型尽量小 127
7.5.4　为列前缀建立索引 128
7.5.5　覆盖索引 129
7.5.6　让索引列以列名的形式在搜索条件中单独出现 129
7.5.7　新插入记录时主键大小对效率的影响 129
7.5.8　冗余和重复索引 130
7.6　总结 131
第8章　数据的家——MySQL的数据目录 132
8.1　数据库和文件系统的关系 132
8.2　MySQL数据目录 132
8.2.1　数据目录和安装目录的区别 132
8.2.2　如何确定MySQL中的数据目录 132
8.3　数据目录的结构 133
8.3.1　数据库在文件系统中的表示 133
8.3.2　表在文件系统中的表示 134
8.3.3　其他的文件 137
8.4　文件系统对数据库的影响 137
8.5　MySQL系统数据库简介 138
8.6　总结 138
第9章　存放页面的大池子——InnoDB的表空间 140
9.1　回忆一些旧知识 140
9.1.1　页面类型 140
9.1.2　页面通用部分 141
9.2　独立表空间结构 142
9.2.1　区的概念 142
9.2.2　段的概念 144
9.2.3　区的分类 145
9.2.4　段的结构 149
9.2.5　各类型页面详细情况 150
9.2.6　Segment Header结构的运用 156
9.2.7　真实表空间对应的文件大小 157
9.3　系统表空间 158
9.4　总结 164
第10章　条条大路通罗马——单表访问方法 166
10.1 访问方法的概念 167
10.2 const 167
10.3 ref 168
10.4 ref_or_null 170
10.5 range 171
10.6 index 171
10.7 all 172
10.8 注意事项 172
10.8.1 重温二级索引+回表 172
10.8.2　索引合并 173
10.9　总结 177
第11章　两个表的亲密接触——连接的原理 178
11.1　连接简介 178
11.1.1　连接的本质 178
11.1.2　连接过程简介 180
11.1.3　内连接和外连接 181
11.2　连接的原理 185
11.2.1　嵌套循环连接 186
11.2.2　使用索引加快连接速度 187
11.2.3　基于块的嵌套循环连接 188
11.3　总结 189
第12章　谁最便宜就选谁——基于成本的优化 190
12.1　什么是成本 190
12.2　单表查询的成本 190
12.2.1　准备工作 190
12.2.2　基于成本的优化步骤 191
12.2.3　基于索引统计数据的成本计算 198
12.3　连接查询的成本 201
12.3.1　准备工作 201
12.3.2　条件过滤（Condition Filtering） 201
12.3.3　两表连接的成本分析 203
12.3.4　多表连接的成本分析 205
12.4　调节成本常数 206
12.4.1　mysql.server_cost表 206
12.4.2　mysql.engine_cost表 208
12.5　总结 209
第13章　兵马未动，粮草先行——InnoDB统计数据是如何收集的 210
13.1　统计数据的存储方式 210
13.2　基于磁盘的永久性统计数据 211
13.2.1　innodb_table_stats 211
13.2.2　innodb_index_stats 214
13.2.3　定期更新统计数据 215
13.2.4　手动更新innodb_table_stats和innodb_index_stats表 216
13.3　基于内存的非永久性统计数据 217
13.4　innodb_stats_method的使用 217
13.5　总结 219
第14章　基于规则的优化（内含子查询优化二三事） 220
14.1　条件化简 220
14.1.1　移除不必要的括号 220
14.1.2　常量传递 220
14.1.3　移除没用的条件 221
14.1.4　表达式计算 221
14.1.5　HAVING子句和WHERE子句的合并 221
14.1.6　常量表检测 221
14.2　外连接消除 222
14.3　子查询优化 224
14.3.1　子查询语法 225
14.3.2　子查询在MySQL中是怎么执行的 230
14.4　总结 244
第15章　查询优化的百科全书——EXPLAIN详解 245
15.1　执行计划输出中各列详解 246
15.1.1　table 246
15.1.2　id 247
15.1.3　select_type 249
15.1.4　partitions 252
15.1.5　type 252
15.1.6　possible_keys和key 255
15.1.7　key_len 256
15.1.8　ref 258
15.1.9　rows 258
15.1.10　filtered 259
15.1.11　Extra 260
15.2　JSON格式的执行计划 266
15.3　Extented EXPLAIN 268
15.4　总结 269
第16章　神兵利器——optimizer trace的神奇功效 270
16.1 optimizer trace简介 270
16.2　通过optimizer trace分析查询优化器的具体工作过程 271
第17章　调节磁盘和CPU的矛盾——InnoDB的Buffer Pool 278
17.1　缓存的重要性 278
17.2　InnoDB的Buffer Pool 278
17.2.1　啥是Buffer Pool 278
17.2.2　Buffer Pool内部组成 278
17.2.3　free链表的管理 279
17.2.4　缓冲页的哈希处理 280
17.2.5　flush链表的管理 281
17.2.6　LRU链表的管理 282
17.2.7　其他的一些链表 286
17.2.8　刷新脏页到磁盘 287
17.2.9　多个Buffer Pool实例 287
17.2.10　innodb_buffer_pool_chunk_size 288
17.2.11　配置Buffer Pool时的注意事项 289
17.2.12　查看Buffer Pool的状态信息 291
17.3　总结 293
第18章　从猫爷借钱说起——事务简介 294
18.1　事务的起源 294
18.1.1　原子性（Atomicity） 295
18.1.2　隔离性（Isolation） 295
18.1.3　一致性（Consistency） 296
18.1.4　持久性（Durability） 298
18.2　事务的概念 298
18.3　MySQL中事务的语法 300
18.3.1　开启事务 300
18.3.2　提交事务 301
18.3.3　手动中止事务 302
18.3.4　支持事务的存储引擎 302
18.3.5　自动提交 303
18.3.6　隐式提交 304
18.3.7　保存点 305
18.4　总结 307
第19章　说过的话就一定要做到——redo日志 308
19.1　事先说明 308
19.2　redo日志是啥 308
19.3　redo日志格式 309
19.3.1　简单的redo日志类型 309
19.3.2　复杂一些的redo日志类型 311
19.3.3　redo日志格式小结 314
19.4　Mini-Transaction 315
19.4.1　以组的形式写入redo日志 315
19.4.2　Mini-Transaction的概念 319
19.5　redo日志的写入过程 319
19.5.1　redo log block 319
19.5.2　redo日志缓冲区 320
19.5.3　redo日志写入log buffer 321
19.6　redo日志文件 323
19.6.1　redo日志刷盘时机 323
19.6.2　redo日志文件组 323
19.6.3　redo日志文件格式 324
19.7　log sequence number 327
19.7.1　flushed_to_disk_lsn 328
19.7.2　lsn值和redo日志文件组中的偏移量的对应关系 330
19.7.3　flush链表中的lsn 330
19.8　checkpoint 332
19.9　用户线程批量从flush链表中刷出脏页 335
19.10　查看系统中的各种lsn值 335
19.11　innodb_flush_log_at_trx_commit的用法 336
19.12　崩溃恢复 336
19.12.1　确定恢复的起点 337
19.12.2　确定恢复的终点 337
19.12.3　怎么恢复 337
19.13　遗漏的问题：LOG_BLOCK_HDR_NO是如何计算的 339
19.14　总结 340
第20章　后悔了怎么办——undo日志 342
20.1　事务回滚的需求 342
20.2　事务id 343
20.2.1　分配事务id的时机 343
20.2.2　事务id是怎么生成的 343
20.2.3　trx_id隐藏列 344
20.3　undo日志的格式 344
20.3.1　INSERT操作对应的undo日志 345
20.3.2　DELETE操作对应的undo日志 347
20.3.3　UPDATE操作对应的undo日志 353
20.3.4　增删改操作对二级索引的影响 357
20.4　通用链表结构 357
20.5　FIL_PAGE_UNDO_LOG页面 359
20.6　Undo页面链表 361
20.6.1　单个事务中的Undo页面链表 361
20.6.2　多个事务中的Undo页面链表 362
20.7　undo日志具体写入过程 363
20.7.1　段的概念 363
20.7.2　Undo Log Segment Header 364
20.7.3　Undo Log Header 365
20.7.4　小结 367
20.8　重用Undo页面 368
20.9　回滚段 369
20.9.1　回滚段的概念 369
20.9.2　从回滚段中申请Undo页面链表 371
20.9.3　多个回滚段 372
20.9.4　回滚段的分类 374
20.9.5　roll_pointer的组成 374
20.9.6　为事务分配Undo页面链表的详细过程 375
20.10　回滚段相关配置 376
20.10.1　配置回滚段数量 376
20.10.2　配置undo表空间 376
20.11　undo日志在崩溃恢复时的作用 377
20.12　总结 377
第21章　一条记录的多副面孔——事务隔离级别和MVCC 379
21.1 事前准备 379
21.2 事务隔离级别 379
21.2.1 事务并发执行时遇到的一致性问题 382
21.2.2 SQL标准中的4种隔离级别 385
21.2.3　MySQL中支持的4种隔离级别 386
21.3　MVCC原理 388
21.3.1　版本链 388
21.3.2　ReadView 390
21.3.3　二级索引与MVCC 397
21.3.4　MVCC小结 397
21.4　关于purge 398
21.5　总结 399
第22章 工作面试老大难——锁 401
22.1　解决并发事务带来问题的两种基本方式 401
22.1.1　写-写情况 401
22.1.2 读-写或写-读情况 403
22.1.3　一致性读 404
22.1.4　锁定读 404
22.1.5　写操作 405
22.2　多粒度锁 406
22.3　MySQL中的行锁和表锁 408
22.3.1　其他存储引擎中的锁 408
22.3.2　InnoDB存储引擎中的锁 409
22.3.3　InnoDB锁的内存结构 417
22.4　语句加锁分析 423
22.4.1　普通的SELECT语句 423
22.4.2　锁定读的语句 424
22.4.3　半一致性读的语句 441
22.4.4　INSERT语句 442
22.5　查看事务加锁情况 444
22.5.1　使用information_schema数据库中的表获取锁信息 444
22.5.2　使用SHOW ENINGE INNODB STATUS获取锁信息 446
22.6　死锁 450
22.7　总结 454
参考资料 455
```

从今天(01/18/2022)开始，起开它的阅读之旅。

你会学到什么？
===
- MySQL 的一些基本概念；
- 如何处理使用 MySQL 过程中的乱码问题；
- 从根儿上理解 InnoDB 存储引擎是如何存储记录、数据页，以及由页作为节点组成的B+树索引的原理；
- 理解 InnoDB 存储引擎的表空间概念，知道 InnoDB 是如何管理段、区、页这些玩意儿以及 InnoDB 的数据字典；
- 理解 MySQL 是如何执行单表查询、如何执行连接查询；
- 理解 MySQL 基于代价的优化和基于规则的优化到底是啥意思；
- 知道如何查看自己写的查询语句是好是坏，学会使用optimizer tracer；
- 理解为什么需要事务以及它的基本概念；
- redo 和 undo 日志的作用以及在 MySQL 中这些日志的细节；
- 理解并发带来的各种问题以及 MySQL 中使用锁的各种细节；
- 理解学习的快乐，希望各位看完本小册就像是读完一本小说一样畅快淋漓。
