# Python垃圾回收---缓存机制

小结
===
在python中维护了一个refchain的双向循环链表，这个链表中存储程序创建的所有对象，每种类型的对象中都有一个ob_refcnt引用计数器的值，引用个数+1，-1，最后当引用计数器变为0时会进行垃圾回收(对象销毁，refchain中移除)。
但是，在python中对于那些可以有多个元素组成的对象可能会存在循环引用的问题，为了解决这个问题，python又引入了标记清除和分代回收，在其内部维护了4个链表：
* refchain
* 2代
* 1代
* 0代

在源码内部当达到各自的阈值时，就会触发扫描链表进行标记清除的动作。
分代回收是为了提升标记清除的回收效率。

源码内部在上述的流程中提出了优化机制。

Python缓存
===
* 池 (int)
为了避免重复创建和销毁一些常见对象，维护池。
```python
v1 = 7
v2 = 9
v3 = 9
```
启动解释器时，python内部会帮我们创建：-5， -4， ..., 257，这些常用的小整数 (refcnt=1)
`v1 = 7`, 内部不会开辟内存，直接去池中获取；
`v1 = 9`, 内部不会开辟内存，直接去池中获取；refcnt=2
`v2 = 9`, 内部不会开辟内存，直接去池中获取，将引用计数器+1; refcnt=3

```python
v4 = 999
v5 = 666
v6 = 666
```
上述的3个变量都会创建3个对象，它们不属于小数范围。

* free_list
当一个对象的引用计数器为0时，按理说应该回收，python内部不会直接回收，而是将这些对象添加到free_list链表中当做缓存。以后再去创建对象时，不再重新开辟内存，而是直接使用free_list。
```python
v1 = 3.14 # 开辟内存，内部存储结构体定义的那几个值，并存到refchain中。
del v1 # refchain移除，将对象添加到free_list中。（可能有个数限制，满了则进行销毁）

v9 = 999.99 # 不会重新开辟内存，去free_list中获取对象，对象内部数据初始化，再放到refchain中。
```
